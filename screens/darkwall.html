<!DOCTYPE html>
<div id="darkwall-screen" class="app-screen hidden">
    <div class="screen-header">
        <h2 data-lang="darkwall">Темная Стена</h2>
        <button class="close-btn">✕</button>
    </div>

    <div class="screen-content">
        <div class="game-container">
            <div class="menu" id="main-menu">
                <h1>MobOS_DemoGame</h1>
                <button onclick="startGame('solo')" data-lang="solo_mode">Одиночная</button>
                <button onclick="startGame('duo')" data-lang="duo_mode">Для двух игроков</button>
            </div>

            <div class="menu hidden" id="solo-mode">
                <h1 data-lang="choose_side">Выберите сторону</h1>
                <button onclick="setMode('attack')" data-lang="attack">Атака</button>
                <button onclick="setMode('defense')" data-lang="defense">Защита</button>
                <button onclick="showMainMenu()" data-lang="back">Назад</button>
            </div>

            <div id="board" class="hidden"></div>
            <div class="status" id="status"></div>
            <button id="ready-btn" class="hidden" onclick="confirmMines()" data-lang="ready">Готово</button>
            <button id="back-btn" class="hidden" onclick="showMainMenu()" data-lang="back">Назад</button>
        </div>

        <div id="notification" class="notification hidden"></div>

        <div id="game-over-menu" class="game-over-menu hidden">
            <h1 id="game-over-title"></h1>
            <button onclick="showMainMenu()" data-lang="ok">ОК</button>
        </div>
    </div>
</div>

<style>
    .game-container {
        margin: 20px auto;
        max-width: 400px;
        padding: 10px;
    }

    .row {
        display: flex;
        justify-content: center;
        margin: 5px 0;
        opacity: 1;
        transition: all 0.3s;
    }

    .cell {
        width: 50px;
        height: 50px;
        border: 2px solid var(--text-color);
        margin: 2px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        background-color: var(--accent-dark);
        border-radius: 10px;
        transition: all 0.3s;
    }

    .cell.revealed {
        background: var(--bg-color-light);
        border: 2px solid var(--accent-color);
    }

    .cell.mine {
        background: linear-gradient(45deg, #ff4444, #cc0000);
    }

    .row.completed {
        opacity: 0.6;
        filter: brightness(0.7);
        pointer-events: none;
    }

    .row.active {
        background-color: var(--accent-color);
        border-radius: 10px;
        padding: 5px;
    }

    .menu {
        background-color: var(--bg-color-light);
        padding: 20px;
        border-radius: 10px;
        margin: 20px auto;
        max-width: 300px;
    }

    .menu button {
        margin: 10px;
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
        background-color: var(--accent-dark);
        color: var(--text-color);
        border: 2px solid var(--text-color);
        border-radius: 5px;
        width: 200px;
    }

    .status {
        margin: 10px 0;
        font-size: 18px;
        color: var(--text-color);
        text-align: center;
    }

    .notification {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: var(--bg-color-light);
        color: var(--text-color);
        padding: 10px 20px;
        border-radius: 5px;
        font-size: 16px;
        z-index: 1000;
        animation: fadeOut 2s forwards;
    }

    .game-over-menu {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: var(--bg-color-light);
        padding: 20px;
        border-radius: 10px;
        text-align: center;
        z-index: 1000;
    }

    @keyframes fadeOut {
        0% { opacity: 1; }
        90% { opacity: 1; }
        100% { opacity: 0; display: none; }
    }
</style>

<script>
    // Глобальное состояние игры
    let gameState = {
        rows: 7,
        cols: 4,
        minesPerRow: 2,
        board: [],
        currentMode: null,
        playerHealth: 100,
        currentRow: 0,
        isDefensePhase: true,
        gameMode: null,
        isScriptAttacking: false
    };

    function initDarkwall() {
        createBoard();
        showMainMenu();
        applyThemeStyles();
    }

    function applyThemeStyles() {
        const root = document.documentElement;
        const theme = localStorage.getItem('theme') || 'theme-1';
        
        if (theme === 'theme-1') {
            root.style.setProperty('--accent-dark', '#004d00');
            root.style.setProperty('--accent-color', '#008000');
        } else {
            root.style.setProperty('--accent-dark', '#1a0033');
            root.style.setProperty('--accent-color', '#4b0082');
        }
    }

    function showDarkwall() {
        document.getElementById('darkwall-screen').style.display = 'block';
        initDarkwall();
    }

    function createBoard() {
        const boardElement = document.getElementById('board');
        boardElement.innerHTML = '';
        gameState.board = [];

        for (let i = 0; i < gameState.rows; i++) {
            const row = document.createElement('div');
            row.className = 'row hidden';
            gameState.board[i] = [];

            for (let j = 0; j < gameState.cols; j++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.row = i;
                cell.dataset.col = j;
                cell.addEventListener('click', () => handleCellClick(i, j, cell));
                row.appendChild(cell);
                gameState.board[i][j] = { isMine: false, revealed: false };
            }
            boardElement.appendChild(row);
        }
    }

    function handleCellClick(row, col, cell) {
        if (gameState.isScriptAttacking) return;

        if (gameState.isDefensePhase) {
            handleDefenseClick(row, col, cell);
        } else {
            handleAttackClick(row, col, cell);
        }
    }

    function handleDefenseClick(row, col, cell) {
        if (gameState.board[row][col].isMine) return;

        const minesInRow = gameState.board[row].filter(c => c.isMine).length;
        if (minesInRow >= gameState.minesPerRow) {
            showNotification(translate('max_mines_reached', {count: gameState.minesPerRow}));
            return;
        }

        gameState.board[row][col].isMine = true;
        cell.classList.add('mine');

        if (minesInRow + 1 === gameState.minesPerRow) {
            document.querySelectorAll('.row')[row].classList.add('completed');
        }
    }

    function handleAttackClick(row, col, cell) {
        if (row !== gameState.currentRow || gameState.board[row][col].revealed) return;

        gameState.board[row][col].revealed = true;

        if (gameState.board[row][col].isMine) {
            cell.classList.add('mine');
            gameState.playerHealth -= 25;
            updateStatus(translate('mine_hit', {health: gameState.playerHealth}));
            if (gameState.playerHealth <= 0) {
                endGame(false);
            }
        } else {
            cell.classList.add('revealed');
            document.querySelectorAll('.row')[gameState.currentRow].classList.remove('active');
            document.querySelectorAll('.row')[gameState.currentRow].classList.add('completed');
            gameState.currentRow++;

            if (gameState.currentRow < gameState.rows) {
                document.querySelectorAll('.row')[gameState.currentRow].classList.remove('hidden');
                document.querySelectorAll('.row')[gameState.currentRow].classList.add('active');
                updateStatus(translate('progress_row', {row: gameState.currentRow + 1}));
            } else {
                endGame(true);
            }
        }
    }

    function startGame(mode) {
        gameState.gameMode = mode;
        document.getElementById('main-menu').classList.add('hidden');

        if (mode === 'solo') {
            document.getElementById('solo-mode').classList.remove('hidden');
        } else {
            startDefensePhase();
        }
    }

    function setMode(mode) {
        gameState.currentMode = mode;
        document.getElementById('solo-mode').classList.add('hidden');
        document.getElementById('board').classList.remove('hidden');

        if (mode === 'attack') {
            createBoard();
            placeRandomMines();
            startAttackPhase();
        } else {
            startDefensePhase();
        }
    }

    function placeRandomMines() {
        for (let i = 0; i < gameState.rows; i++) {
            let placed = 0;
            while (placed < gameState.minesPerRow) {
                const col = Math.floor(Math.random() * gameState.cols);
                if (!gameState.board[i][col].isMine) {
                    gameState.board[i][col].isMine = true;
                    placed++;
                }
            }
        }
    }

    function startDefensePhase() {
        gameState.isDefensePhase = true;
        createBoard();
        document.getElementById('board').classList.remove('hidden');
        document.getElementById('ready-btn').classList.remove('hidden');
        document.getElementById('back-btn').classList.remove('hidden');
        document.querySelectorAll('.row').forEach(row => {
            row.classList.remove('hidden');
            row.style.pointerEvents = 'auto';
        });
        updateStatus(translate('place_mines', {count: gameState.minesPerRow}));
    }

    function confirmMines() {
        for (let i = 0; i < gameState.rows; i++) {
            if (gameState.board[i].filter(c => c.isMine).length !== gameState.minesPerRow) {
                showNotification(translate('row_not_complete', {row: i + 1}));
                return;
            }
        }
        document.getElementById('back-btn').classList.add('hidden');
        hideMines();
        startAttackPhase();
    }

    function hideMines() {
        document.querySelectorAll('.mine').forEach(cell => {
            cell.classList.remove('mine');
        });
    }

    function startAttackPhase() {
        gameState.isDefensePhase = false;
        document.getElementById('ready-btn').classList.add('hidden');

        document.querySelectorAll('.row').forEach((row, index) => {
            if (index === 0) {
                row.classList.remove('hidden');
                row.classList.add('active');
            } else {
                row.classList.add('hidden');
            }
        });

        if (gameState.gameMode === 'duo' || gameState.currentMode === 'attack') {
            updateStatus(translate('start_first_row'));
            document.getElementById('back-btn').classList.remove('hidden');
        } else if (gameState.currentMode === 'defense') {
            updateStatus(translate('script_attacking'));
            simulateAttacker();
        }
    }

    function simulateAttacker() {
        gameState.isScriptAttacking = true;
        const interval = setInterval(() => {
            if (gameState.currentRow >= gameState.rows || gameState.playerHealth <= 0) {
                clearInterval(interval);
                gameState.isScriptAttacking = false;
                endGame(gameState.currentRow < gameState.rows);
                return;
            }

            const col = Math.floor(Math.random() * gameState.cols);
            const cell = document.querySelector(`.cell[data-row='${gameState.currentRow}'][data-col='${col}']`);

            if (!gameState.board[gameState.currentRow][col].revealed) {
                if (gameState.board[gameState.currentRow][col].isMine) {
                    cell.classList.add('mine', 'revealed');
                    gameState.playerHealth -= 25;
                    updateStatus(translate('script_mine_hit', {health: gameState.playerHealth}));
                } else {
                    cell.classList.add('revealed');
                    document.querySelectorAll('.row')[gameState.currentRow].classList.remove('active');
                    document.querySelectorAll('.row')[gameState.currentRow].classList.add('completed');
                    gameState.currentRow++;

                    if (gameState.currentRow < gameState.rows) {
                        document.querySelectorAll('.row')[gameState.currentRow].classList.remove('hidden');
                        document.querySelectorAll('.row')[gameState.currentRow].classList.add('active');
                        updateStatus(translate('script_next_row', {row: gameState.currentRow + 1}));
                    }
                }
                gameState.board[gameState.currentRow][col].revealed = true;
            }
        }, 1000);
    }

    function endGame(isWin) {
        const gameOverMenu = document.getElementById('game-over-menu');
        const gameOverTitle = document.getElementById('game-over-title');
        gameOverTitle.textContent = isWin ? translate('victory') : translate('defeat');
        gameOverMenu.classList.remove('hidden');
    }

    function updateStatus(text) {
        document.getElementById('status').textContent = text;
    }

    function showMainMenu() {
        document.getElementById('main-menu').classList.remove('hidden');
        document.getElementById('solo-mode').classList.add('hidden');
        document.getElementById('back-btn').classList.add('hidden');
        document.getElementById('board').classList.add('hidden');
        document.getElementById('ready-btn').classList.add('hidden');
        document.getElementById('game-over-menu').classList.add('hidden');
        document.getElementById('notification').classList.add('hidden');
        resetGame();
    }

    function resetGame() {
        gameState.playerHealth = 100;
        gameState.currentRow = 0;
        gameState.isDefensePhase = true;
        gameState.currentMode = null;
        gameState.gameMode = null;
        gameState.isScriptAttacking = false;
        createBoard();
    }

    function showNotification(message) {
        const notification = document.getElementById('notification');
        notification.textContent = message;
        notification.classList.remove('hidden');
        setTimeout(() => {
            notification.classList.add('hidden');
        }, 2000);
    }

    function translate(key, params = {}) {
        const lang = localStorage.getItem('language') || 'ru';
        let translation = window.translations[lang]?.[key] || window.translations['ru'][key] || key;
        
        for (const [param, value] of Object.entries(params)) {
            translation = translation.replace(`{${param}}`, value);
        }
        
        return translation;
    }

    // Экспорт функций для глобального доступа
    window.initDarkwall = initDarkwall;
    window.showDarkwall = showDarkwall;
    window.startGame = startGame;
    window.setMode = setMode;
    window.confirmMines = confirmMines;
    window.showMainMenu = showMainMenu;
</script>
